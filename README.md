
Introduction
============

During a Phd, it often arises the need to test *something* (e.g., an algorithm, a framework) over a 
*combination of parameters*. For instance, in the context of path planning, there are several algorithms, 
all of them with their wistles and tweaks, you can use to compute the shortest path
from a source to the target: you can use A* and several heuristics (like landmarks or euclidean distance), or you can use Dijkstra. The performance
of the algorithm under test may change over the *environment* where it is tested: 
for example an algorithm may perform better over a map and worse over another one. 
Even worse, this environment may have its own parameters as well: for instance  environment may have 
different set of path planning queries (simple, medium, difficult).

Therefore, you often need to test *some stuff* which has its own options over an environment which
 has its own options as well. Often, you need to generate performances plot over all those combinations.

This problem can be solved by the PhdTester. It's a framework that lets you:
 
1. generate all the test combinations;
2. plot the result;
3. and aggregate them in a pdf report.
 
Installation
============

Installation is very easy, just use:

```
pip install phd-tester
```

You may need to do this other step as well:

```
pip install dask[dataframe] --upgrade
```

Requirements
============

Phd Tester requires some additional tools in order to fully work. 
 - it needs `pdflatex` to generate the report. Hence, if you care about the report, 
 be sure to install it. For systems like Ubuntu, this can be effectively done via:

```
sudo apt-get install tex-live
```
 - It needs `dot` to generate a visual representation of the *optionGraph*. To be able to do this,
   execute the command:
   
```
sudo apt-get install graphviz
```

Concepts
========

n the following we will list important concepts that needs to be understood in order to use the framework:

Stuff under test
----------------

The "stuff under test" is the algorithm, procedure, model that you want to benchmark together with every 
configuration attached to it. For example if you want to test sorting algorithms, "stuffs under test" is 
the quicksort, bubblesort, mergesort, heapsort, randomsort. If a "stuff under test" has a parameter 
(for instance, heapsort implementation may require the maximum size of the underlying heap), such parameter 
is included in the "stuff under test". "Stuff under test" is treated in a special way when computing 
plots and csvs, so be sure to correctly identifying it;

Test Environment
----------------

The "test environment" are all the options which are not directly linked with your algorithm, but represents the context
where the algorithm is run in. For exmaple in the context of sorting algorithms, a test environment option
is the option representing the length of the sequence you want sort or the status the original sequence is:
 - random initialized;
 - already sorted;
 - reverse sorted;
 
Test Context
------------

The test context is a structure that uniquely identifies a single run of your algorithm. Thanks to the test context,
you can derive **all** the parameters identifying your test. This is by definition the union of "stuff under test"
options and "test environment" options.

KS001 Standard
--------------

During testing algorithms, it's often necessary to create files representing a certain situation. For example, if you need to generate plots showing the trend of the algorithms on different test environment, you need to generate png images with unique names (e.g., "mean time over query id", "standard deviation of time over query id", "standard deviation of time over query id when sequence is randomly initialized" "standard deviation of time over query id when sequence is already sorted"). This naming often applies also to the **data container** (often csv files) representing the data generated by the algorithms under tests (e.g., "quick sort performances", "merge sort performances", "merge sort performances when seuqence is randomly initialized").

As you might expect, generating informative names while creating unique names depending the situation is critical to the framework.
For this reason I've developed a standard naming convention all the framework involved file has to satisfy. such standard is called "KS001".

The standard is fully explained below:

### Special characters and Grammar

Given 4 **special characters** called:
  - `=`: separator between a key and a value;
  - `_`: separator between different key/value mappingM
  - `|`: separator of dictionaries;
  - `:`: separator between names and dictionaries.

the KS001 grammar (whose starting point is `filename` representing the filename compliant with the KS001 standard) is the following one:

```
filename := identifier? '|' dictionaries '|' extension?
dictionaries := dictionary ( '|' dictionaries )*
dictionary := name ':' keyvalues* | keyvalues
keyvalues := keyvalue ( '_' keyvalues )*
keyvalue := key '=' value

name := string
identifier := [^|]+
extension := string
key := string
value := string

string := ([^=_|:]|'='{2}|'_'{2}|'|'{2}|':'{2})+
```

### Examples

In practice, here's some examples:

```
|a=5|.png
|basic:a=5|.png
|basic:a=5_b=3|c=4|.png
myIdentifier|basic:a=5_b=3|c=4|.png
```

### Semantics

Generally speaking, the `identifier` is a string which you can use for several reasons:

 - since normally files can be alphabetically sorted on a file system explorer (e.g., Nautilus), you can use the string to force the sorting
 you want;
 - you can give a string which compactly represent the object you want, in order to find the file more easily;

Each dictionary has a label and it can be used in the code to get a particular dictionary you're interested in.

Each dictionary should represent a particular set of key-values involving the same semantic.

Finally key-values represents the fact that such file has a property "key" which has the value "value".

### KS001 Properties

If you need to put a special characters inside either the name, key or value double them. For example:

```
|a::=5|||.png
```

Here the key is `a:` while the value is `5|`

Escaping characters are interpreted greedly (as soon as possible), hence

```
|a===5|.png
```

has a key equal to `a=` and a value of 5 and it is **not** intepreted as a key `a` and a value of `=5`.

The KS001 represents a **ordered** list of dictionaries (optionally named with a label) containing
an **ordered set** of key-value mapping.
Key are string. value needs to be a string convertable element.
The mappings are ordered by **key**: This means that the order is decided by the key alphanumeric value, so for example the key `abc` always comes first of the key `cba`. 

Hence the following one is not a filename KS001 compliant:

```
|b=3_a=2|.png
```

because `b` comes before the key `a`. However the string:

```
|a=2_b=3|.png
```

is KS001 compliant.

Key duplication is not permitted.
Neither key nor values cannot be None.
File extensions are explicitly **outside** every dictionary.

### Unnamed Dictionaries

Unnamed dictionaries cannot be empty. Consider this scenario:

|a=5|||.png

it's should be interpreted as `a=5|` or as `a=5` (and then there are 2 empty dictionaries?).
To solve this issue we explictly avoid empty unnamed dictionaries. You can however have an empty named dictionary, like the following one:

```
|a=5|empty:|.png
```

### Aliases


KS001 directly supports aliasing. Aliases is introduced because dictionaries can be big, hence the generated string may be long. Since several filesystem does not allow for lengthy filename, aliasing is required.

Aliases are mapping of key names into shorter keynames. You can set aliases both on keys and on values. For example if you have set "f" as an alias of "foo", both this dictionaries are semantically the same:

```
|a=5_foo=3|.png
|a=5_f=3|.png
```

As for the keys, no alias can have a None value