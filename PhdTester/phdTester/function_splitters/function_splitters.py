import abc
import os

from phdTester import KS001
from phdTester.common_types import KS001Str

__doc__ = """
This module contains all the splitter we natively support.

Splitter allows you to generate csvs in a more advance way related to the vanilla way to generate them
"""

from typing import Tuple, Any

from phdTester.model_interfaces import IFunctionSplitter, ITestContext, ICsvRow


class BasedOnCsv(IFunctionSplitter):
    """
    Create a new function for each csv we're currently analyzing.

    The function name will be the name of the csv we're analyzing
    """

    def fetch_function(self, x: float, y: float, under_test_function_key: str, csv_tc: "ITestContext",
                       csv_name: KS001Str, csv_ks001: KS001,
                       i: int, csv_outcome: "ICsvRow",
                       colon: str = ':', pipe: str = '|', underscore: str = '_', equal: str = '=') -> Tuple[float, float, str]:

        return x, y, os.path.basename(csv_name)


class BaseOnCsvRow(IFunctionSplitter):
    """
    Create a new function for each csv row we're currently analyzing

    The function name will be the name of the csv we're analyzing, attached with the row number information
    """

    def fetch_function(self, x: float, y: float, under_test_function_key: str, csv_tc: "ITestContext",
                       csv_name: KS001Str, csv_ks001: KS001,
                       i: int, csv_outcome: "ICsvRow",
                       colon: str = ':', pipe: str = '|', underscore: str = '_', equal: str = '=') -> Tuple[float, float, str]:

        new_name = KS001.from_merging(csv_ks001, label="functionSplitter", csvRow=i)
        return x, y, new_name.dump_str(
            colon=colon,
            pipe=pipe,
            underscore=underscore,
            equal=equal,
        )


class GroupOnCSVContextSplitter(IFunctionSplitter, abc.ABC):

    def __init__(self):
        IFunctionSplitter.__init__(self)

    @abc.abstractmethod
    def synthetize_value_from_row(self, tc: "ITestContext", name: KS001Str, row_index: int, row: "ICsvRow") -> Any:
        """
        synthetize a value from the given data row
        :param tc: the test context which has generated the data row
        :param name: name of the data container holding `row`
        :param row_index: the index of `row` inside the data container
        :param row: the data to manage
        :return: a value synthetized from `row'
        """
        pass

    def fetch_new_name(self, old_name: str, group_value: Any) -> str:
        """
        fetch the new name to be generated by the function splitter instead of `old_name`

        :param old_name: the name of the function in input of `function_splitter`
        :param group_value: the value generated by `get_group`
        :return: the name of the function to retrieve. x and y won't be altered at all
        """

    @abc.abstractmethod
    def get_group(self, value: Any, x: float, y: float, function_name: str, csv_tc: "ITestContext", csv_name: str, i: int, csv_output: "ICsvRow") -> Any:
        """
        generate the group the value `value` belongs to
        :param value: the value generated with function `f`
        :param x: the x point considered
        :param y: the y point considered
        :param function_name: the name of the function `x` and `y` tuple is supposed to go to
        :param csv_tc: the test context where this data has been generated from
        :param csv_name: the name of the data source containing `x` and `y`
        :param i: the index of the row we're handling
        :param csv_output: an object representing the row of the csv just read
        :return: a value representing the particular group where this `x` and `y` will go to
        """
        pass

    def fetch_function(self,
                       x: float, y: float, under_test_function_key: str, csv_tc: "ITestContext",
                       csv_name: KS001Str, csv_ks001: KS001,
                       i: int, csv_outcome: "ICsvRow",
                       colon: str = ':', pipe: str = '|', underscore: str = '_', equal: str = '=') -> Tuple[
        float, float, str]:

        val = self.synthetize_value_from_row(csv_tc, csv_name, i, csv_outcome)
        val = self.get_group(val, x, y, under_test_function_key, csv_tc, csv_name, i, csv_outcome)
        name = self.fetch_new_name(under_test_function_key, val)
        return x, y, name
